#!/bin/bash
###
### Stop Hook - Update CSV when Claude response is completed
###

# Project ccptracker directory path
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CCPTRACKER_DIR="$(dirname "$SCRIPT_DIR")"

# Ensure necessary directories exist
mkdir -p "$CCPTRACKER_DIR/temp"
mkdir -p "$CCPTRACKER_DIR/logs"
mkdir -p "$CCPTRACKER_DIR/data"

# Read input data
INPUT=$(cat)

# Debug: log input data
{
    echo "=== Stop Hook Debug Log ==="
    echo "Time: $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""
    echo "Input JSON:"
    echo "$INPUT"
    echo ""
} > "$CCPTRACKER_DIR/logs/stop-hook-debug.log"

# Load session information
SESSION_FILE="$CCPTRACKER_DIR/temp/current-session.json"
if [ ! -f "$SESSION_FILE" ]; then
    # Exit if no session information (executed without prompt submission)
    exit 0
fi

SESSION_ID=$(node -pe "JSON.parse(require('fs').readFileSync('$SESSION_FILE', 'utf8')).session_id")

# Extract transcript file path - use exact path from input first
ORIGINAL_TRANSCRIPT=$(echo "$INPUT" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).transcript_path || ''" 2>/dev/null || echo "")

# Use original transcript path if it exists, otherwise find alternative
TRANSCRIPT_PATH=""

if [ -n "$ORIGINAL_TRANSCRIPT" ] && [ -f "$ORIGINAL_TRANSCRIPT" ]; then
    TRANSCRIPT_PATH="$ORIGINAL_TRANSCRIPT"
else
    # Fallback: find transcript file for current project
    PROJECT_NAME=$(basename "$(pwd)" | sed 's/[^a-zA-Z0-9]/-/g')
    PROJECT_PATH_ENCODED=$(pwd | sed 's|/|-|g')

    # Find transcript matching current project in Claude Code project directory
    CLAUDE_PROJECTS_DIR="$HOME/.claude/projects"

    if [ -d "$CLAUDE_PROJECTS_DIR" ]; then
        # Find transcript directory based on project path
        TRANSCRIPT_DIR=$(find "$CLAUDE_PROJECTS_DIR" -type d -name "*$(basename "$(pwd)")*" | head -1)

        if [ -n "$TRANSCRIPT_DIR" ]; then
            TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | head -1)
        fi

        # If not found, find by encoding current project path
        if [ -z "$TRANSCRIPT_PATH" ]; then
            TRANSCRIPT_DIR=$(find "$CLAUDE_PROJECTS_DIR" -type d -name "*$PROJECT_PATH_ENCODED*" | head -1)
            if [ -n "$TRANSCRIPT_DIR" ]; then
                TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | head -1)
            fi
        fi

        # If still not found, use most recently modified file
        if [ -z "$TRANSCRIPT_PATH" ]; then
            TRANSCRIPT_PATH=$(find "$CLAUDE_PROJECTS_DIR" -name "*.jsonl" -type f -exec ls -t {} + 2>/dev/null | head -1)
        fi
    fi
fi

# Debug: transcript information
{
    echo "Original transcript: $ORIGINAL_TRANSCRIPT"
    echo "Using transcript: $TRANSCRIPT_PATH"
    echo "File size: $(wc -c < "$TRANSCRIPT_PATH" 2>/dev/null || echo 0) bytes"
} >> "$CCPTRACKER_DIR/logs/stop-hook-debug.log"

# Extract session ID from input JSON (if available)
HOOK_SESSION_ID=$(echo "$INPUT" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).session_id || ''" 2>/dev/null || echo "")

# Extract response content (last assistant message from transcript)
RESPONSE=""
TOOLS_USED=""
TOOLS_COUNT=0
MODEL_ID=""
USAGE_JSON=""

if [ -n "$TRANSCRIPT_PATH" ] && [ -f "$TRANSCRIPT_PATH" ]; then
    # Parse transcript with Node.js script, passing session ID
    RESPONSE=$(node "$SCRIPT_DIR/stop-parse-transcript.js" "$TRANSCRIPT_PATH" "$HOOK_SESSION_ID")

    # JSON parsing
    CLAUDE_RESPONSE=$(echo "$RESPONSE" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).response || ''")
    TOOLS_USED=$(echo "$RESPONSE" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).tools_used || ''")
    TOOLS_COUNT=$(echo "$RESPONSE" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).tools_count || 0")
    MODEL_ID=$(echo "$RESPONSE" | node -pe "JSON.parse(require('fs').readFileSync(0, 'utf8')).model || ''")
    USAGE_JSON=$(echo "$RESPONSE" | node -pe "JSON.stringify(JSON.parse(require('fs').readFileSync(0, 'utf8')).usage || {})")

    # Debug: parsing results
    {
        echo ""
        echo "Parsed response length: ${#CLAUDE_RESPONSE}"
        echo "Response preview: ${CLAUDE_RESPONSE:0:200}"
        echo "Tools used: $TOOLS_USED"
        echo "Tools count: $TOOLS_COUNT"
        echo "Model: $MODEL_ID"
        echo "Usage JSON: $USAGE_JSON"
        echo "Session ID: $HOOK_SESSION_ID"
    } >> "$CCPTRACKER_DIR/logs/stop-hook-debug.log"
fi

# Calculate elapsed time (approximate)
START_TIME=$(node -pe "JSON.parse(require('fs').readFileSync('$SESSION_FILE', 'utf8')).timestamp")
END_TIME=$(date '+%Y-%m-%d %H:%M:%S')

# Calculate in seconds
DURATION=$(node -pe "Math.floor((new Date('$END_TIME') - new Date('$START_TIME')) / 1000)")

# Update CSV (response information) - now passes usage JSON as 7th parameter
node "$SCRIPT_DIR/csv-updater.js" update-response "$SESSION_ID" "$CLAUDE_RESPONSE" "$DURATION" "$TOOLS_USED" "$TOOLS_COUNT" "$MODEL_ID" "$USAGE_JSON"

# Save current response session information to SESSION_FILE (for next satisfaction rating)
cat > "$SESSION_FILE" << EOF
{
  "session_id": "$SESSION_ID",
  "timestamp": "$END_TIME",
  "project_path": "$(pwd)"
}
EOF

# Feedback guidance message (return as JSON)
cat << 'EOFMSG'
{
  "decision": "proceed",
  "message": "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n💡 Rate satisfaction: Enter 1-5 in next prompt\n[1] ⭐ Very Poor [2] ⭐⭐ Poor [3] ⭐⭐⭐ Average\n[4] ⭐⭐⭐⭐ Good [5] ⭐⭐⭐⭐⭐ Excellent\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}
EOFMSG

exit 0